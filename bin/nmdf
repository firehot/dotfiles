#!/bin/sh
# Location : $DOTREPO/bin/nmdf
# PURPOSE : 1. launch $DOTREPO/link with parameters 2. Manage dotfiles project: show status/pull/push
# status: unfinished. Last edit on 2016-02-05 . @TODO: --> PROJECT management + help

REPO_URI=https://github.com/titepweb/nmdf
REPO_BRANCH=master
APP_URL=https://raw.githubusercontent.com/titepweb/nmdf/master/bin/nmdf

# Identify ABSOLUTE path of directory storing the script. Scripts sourced by this script will inherit DOTREPO variable.
if [ -L $DOTREPO ] || [ -z $DOTREPO ]; then
  DOTREPO="$( cd -P "$( dirname "$0" )" && pwd )"
  DOTREPO="$(dirname $DOTREPO)"   # which means, this script must be in $DOTREPO/topic/
fi
source $DOTREPO/install/inform
source $DOTREPO/install/cross-platform
source $DOTREPO/install/installpkg true
source $DOTREPO/install/link true

#=[ functions ]================================#

function nmdf_help {
cat << EOF
┌─────────────────────────────────────────────────────────────────────────────┐
│ WORKFLOW                                  │

  (1) Update/Clone dotfiles : $(basename $0) -u [-r repository] [-d path to dir]

    If run from remote location, nmdf automatically clone the REPO_URI
    [$REPO_URI]
    to the working directory or the specified directory that user give through
    the option -d {path to dir}. -d would be useful to manage multiple dotfiles.

  (2) Install dotfiles      : $(basename $0) command [options]
      * command : 
        -l  : Symlink both *.copy and *.symlink  files
        -c  : Copy both *.copy and *.symlink files
        -i  : Install : Copy *.copy files and symlink *.symlink files accordinly. 
              Skip copying if destination file exists.
        -if : Reinstall forcefully : Install dotfiles, do not skip copying.

      * options :
        -o  : Create symlinks without overwrite confirmation.
        -b  : Create symlinks without backup confirmation.
        -a  : Ask user for copying each file or creating each symlink.

  (3) Show statistic data about dotfiles : $(basename $0) -s

  (4) Push dotfiles to VSC  : $(basename $0) [-r repo] -p ["commitMessage"]

      If the commitMessage is not specified or too short, an auto-message will 
      be generated.

  (*) Tips: $(basename $0) -uiba
└─────────────────────────────────────────────────────────────────────────────┘
EOF
}

#### LIBRARIES ALLOWING nmdf TO RUN FROM A REMOTE LOCATION ###################

function updateRepo {
  # Check if git is installed before doing git operations
  type git >/dev/null 2>&1 || { 
    echo "************************************"
    echo >&2 "Git is required to clone/pull/push dot files from/to a remote repository. "\
    "Symlinks can still be auto created to files in $dotDir but a remote repository will not be used.";
    echo "************************************"
    return;
  }

  # if @1="pull" but there is no repo here create one, otherwise update it afterwards.
  if [ "$1" == "pull" -a ! -d "$dotDir/.git" ]; then
    displayTitle "DOWNLOADING MASTER REPOSITORY"
    [ -e "$dotDir"] && FAIL "${red}${bold}$dotDir is a regular file or a not empty directory. 'git clone' only work on empty directory.${reset}"
    git clone -b "$REPO_BRANCH" "$REPO_URI" "$dotDir"
    OK "${green}${bold}Cloning $app_name completed!${reset}"
    return
  fi

  # If dotDir does not exist, return.
  [ ! -d "$dotDir" ] && FAIL "${red}${bold}The dotDir $dotDir does not exist. \nUpdating Repository fails!${reset}"

  # Git Pull or Push
  if [ "$1" == "pull" ]; then
    displayTitle "Pulling changes from the $app_name's repository, branch $REPO_BRANCH"
    (cd $dotDir && git pull origin "$REPO_BRANCH")
    OK "${green}${bold}\nPulling changes from the $app_name completed!${reset}"
  elif [ "$1" == "push" ]; then
    displayTitle "Pushing changes to the $app_name's repository, branch $REPO_BRANCH"
    cd $dotDir && git add . && git commit -m "$commitMessage" && git push origin "$REPO_BRANCH"
    echo -e "${green}${bold}\nPushing changes from the $app_name repository completed!${reset}"
  fi
}

function stats {
  cd $dotDir  # cd to dotdir before du -sh and git add .
  displayTitle "STATISTIC DATA"

  echo -e "-dotfiles in     :${blue}${bold} $dotDir${reset}"
  if [ -e "$dotDirIns" ]; then
    local insState="$(readsymlink "$dotDirIns")"
    if [ "$insState" == "$dotDir" ]; then
      echo -e "-installed in    :${blue}${bold} $dotDirIns${reset}"
    fi
  fi
  if [ ! -e "$dotDirIns" ] || [ -z "$insState" ]; then
    echo -e "-dotDir symlink  :${red}${bold} not installed${reset}"
  fi
  echo -e "-total files     :${yellow}${bold} $(find $dotDir -type f | wc -l)${reset} \t files"
  echo -e "-total directory :${yellow}${bold} $(find $dotDir -type d | wc -l)${reset} \t directories"
  echo -e "-usage           :${red}${bold} $(du -sh)${reset}"
  echo -e "-dotfiles        :${cyan}${bold} $(find $dotDir -type f \
    -not -path "*/.git/*" \
    -not -path "*/.hg/*" \
    -not -path "$tempDir/*" \
    -not -path "$backupDir/*" \
    | wc -l)${reset} \t files"
  echo -e "-dotdirectories  :${cyan}${bold} $(find $dotDir -type d \
    -not -path "*/.git/*" \
    -not -path "*/.hg/*" \
    -not -path "$tempDir/*" \
    -not -path "$backupDir/*" \
    | wc -l)${reset} \t directories"
  echo "-----------------------------------------"
  git add . && git status
  exit 0
}

#### MAIN ####################################################################

# STEP 1 # Parse option arguments or ask for them if not been specified 
# ----------------------------------------------------------------------
  # Overwrite default options set in $DOTREPO/install/link
  overwrite_all=false backup_all=false skip_all=false
  symlinkORcopy=false recopy=false installpkg=false

  if [ $# = 0 ]; then
    nmdf_help
    FAIL "Parameters is needed to execute nmdf."
  fi

  [ "$1" ==  "--help" ] && nmdf_help
  OPTIND=1 # Reset in case getopts has been used previously in the shell.
  #NOTE: Never use getopt (Traditional versions of getopt cannot handle empty argument strings, or arguments with embedded whitespace.)
  while getopts :uclIifaobsd:r:p: OPTION; do
    case $OPTION in
      u)  pullOption=true ;;
      I)  installpkg=true ; symlinkORcopy="true" ;;
      # parameters for $DOTREPO/install/link {{{
      c)  symlinkORcopy="copy" ;;
      l)  symlinkORcopy="symlink" ;;
      i)  symlinkORcopy="symlink+copy" ;;
      f)  recopy=true ;;
      a)  askbeforeaction=true ;;
      o)  overwrite_all=true ;;
      b)  backup_all=true ;;
      # }}}
      s)  showStats=true ;;
      d)  dotDir=$OPTARG ;;
      r)  REPO_URI=$OPTARG ;;
      p)  pushOption=true ;
          commitMessage=$OPTARG
          [[ -z "$commitMessage" ]] || [[ ${#commitMessage} -lt 4 ]] && commitMessage="Auto commit dot files at $(date)"
      ;;
      :)  #@FIXME: This option is not considered if p,d,r option is follow by another argument; for example, nmdf -dr , nmdf -pa. So, nmdf -ap is desired instead of nmdf -pa
          if [ "$OPTARG" == "p" -a -z "${commitMessage// }" ]; then
            commitMessage="Auto commit dot files at $(date)"
            echo "Automatic commit message :"$commitMessage
          else
            echo "Option -$OPTARG requires an argument. Type nmdf -h for usage."
            exit 1
          fi
      ;;
      h|\?) # if unrecognized option - show help
          nmdf_help
          exit 1
      ;;
    esac
  done
  shift $((OPTIND-1))  #This tells getopts to move on to the next argument.

# STEP 2 # - Create a working copy of the dofiles repository.
#          - Pull changes if dotfiles repository exists.
#          - Evaluate the default parameters or what user typed (-d directory).
#------------------------------------------------------------------------------
  [ "$pullOption" == "true" ] && updateRepo "pull"

  # @FIXME:
  # sh -c "`curl -fsSL https://raw.githubusercontent.com/titepweb/nmdf/master/bin/nmdf`"
  # sh -c "$(wget https://raw.githubusercontent.com/titepweb/nmdf/master/bin/nmdf -O -)"
  # bash <(wget -nv -O -https://raw.githubusercontent.com/titepweb/nmdf/master/bin/nmdf)
  # if this script is running from a remote location and the dotfiles directory was empty, download and save nmdf to the bin directory, however, 
  if [ ! -f "$binDir/nmdf" ] && [ ! hash nmdf >/dev/null 2>&1 ]; then
    curl -fsSL -o "$binDir/nmdf" $APP_URL
    chmod +x "$binDir/nmdf"
  fi

  # After pulling, dotDir must be created or filled with content. So, Quit if dotDir does not exist.
  [ ! -d "$dotDir" ] && FAIL "Dotfile directory ${red}'$dotDir'${reset} does not exist. nmdf is terminated."

# STEP 3 # Update submodules. Install dotfiles by creating symlinks. Backup existed dotfiles if necessary.
#---------------------------------------------------------------------------------------------------------
  [ "$installpkg" == "true" ] && INSTALL_PACKAGES
  [ "$symlinkORcopy" != "false" ] && INSTALL_DOTFILES
    # for the first time, submodule need to be 
    # displayTitle "INITIALIZING SUBMODULES"
    # cd "$dotDir" && git submodule update --init --recursive #--recrusive means update all submodules within
  [ "$showStats" == "true" ] && stats

# STEP 4 # Push changes to the nmdf repository, which is useful if nmdf renamed/created directories
#----------------------------------------------------------------------------------------------------
  [ "$pushOption" == "true" ] && updateRepo "push"

# STEP 3 -- DISPLAY WARNING MESSAGE
echo -e "\n$message"

exit 0



#### FUNCTION BANK ###########################################################

# ContextualSymlinkList

  for file in $(find "$topic" -type f -name .install.sh \
                -not -path "*/*\.ingore/*" \
                -not -path "*/*\.80%/*" \
              ); do
    INFO "Source ${cyan}$file${reset}"
    source "$file"
  done


  # RemoveTailing function can be rewritten :
  for i in `seq 1 10`; #10 here is customizable
    do
      find "$1" -mindepth $i -maxdepth $i -name '*.symlink' -exec sh -c ' {
        if [[ $0 =~ .*\.symlink/.*\.symlink$ ]]; then
          mv "$0" "${0%.symlink}"
          count_rename=$(($count_rename+1))
          echo -e "  [\e[31mrename\e[0m] ${0%.symlink}\e[9;31m.symlink\e[0m"
        fi
      }' {} \;
    done
          -not -path "$tempDir/*" \

  # Before I find out mkdir can make multi-level directories, I use this to test if a directory contains .symlink file(s) or not.
  # If a directory has a *.symlink file inside, I use the following codes to make sure that the destination directory exists before creating the corresponding symlinks.
  if [ -d "$src" ]; then
    local results=( $(find "$src" -name "*.symlink") )
    if (( ${#results[@]} )) ; then
      if [[ -d "$dst" ]]; then
        SCAN "Existed $dst" 
      else
        mkdir -p "$dst"
        OK "Created $dst"
      fi
    else
      SCAN "Not found any *.symlink files in $src"
    fi
  fi 

# ✱✗—•…›✔i


# Recursively look for the target which $dotDir points to: 
# a modified version from : http://stackoverflow.com/questions/59895/can-a-bash-script-tell-what-directory-its-stored-in/246128#246128
SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
  DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
  SOURCE="$(readsymlink "$SOURCE")"
  [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE" # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
done
  dotDir="$( cd -P "$( dirname "$SOURCE" )/.." && pwd )"  #--> nmdf must be in $binDir, not in $dotDir
if [ -z "$dotDir" ]; then
fi

# Trim the trailing slash from the dot directory if user mistyped.
[[ $dotDir == */ ]] && dotDir="${dotDir%?}"  # OR dotDir=${dotDir:1}


